namespace HoaMokuBot.Handlers{    using Discord;    using Discord.WebSocket;    using HoaMokuBot.Handlers.Contracts;     public class MusicStatusHandler : IMusicStatusHandler    {        private readonly IMusicLavaPlayerHandler musicLavaPlayerHandler;        private readonly IPlaylist playlist;        private readonly IMusicEmbedHandler musicEmbedHandler;        private readonly IMusicMessageComponentHandler musicMessageComponentHandler;        private IUserMessage? previousTrackInfoMessage;        private IUserMessage? previousPlaylistInfoMessage;        public MusicStatusHandler(IMusicLavaPlayerHandler musicLavaPlayerHandler, IPlaylist playlist, IMusicEmbedHandler musicEmbedHandler, IMusicMessageComponentHandler musicMessageComponentHandler)        {            this.musicLavaPlayerHandler = musicLavaPlayerHandler;            this.playlist = playlist;            this.musicEmbedHandler = musicEmbedHandler;            this.musicMessageComponentHandler = musicMessageComponentHandler;        }        public async Task UpdateStatus(SocketGuild socketGuild, IMessageChannel channel, string status)        {            if (String.IsNullOrWhiteSpace(status))            {                return;            }            var player = this.musicLavaPlayerHandler.TryGetPlayer(socketGuild);            if (player == null)            {                await channel.SendMessageAsync(status);                return;            }            if (this.previousTrackInfoMessage != null)            {                IMessage? lastMessage = null;                try                {                    lastMessage = (await channel.GetMessagesAsync(1).FlattenAsync()).FirstOrDefault();                }                // ReSharper disable once EmptyGeneralCatchClause                catch                {                }                if (lastMessage != null && lastMessage.Id != this.previousTrackInfoMessage?.Id)                {                    this.previousTrackInfoMessage = null;                }            }            if (this.previousTrackInfoMessage != null)            {                if (this.playlist.Current() == null)                {                    await channel.SendMessageAsync(status);                }                else                {                    var trackInfo = await this.musicEmbedHandler.CreateTrackInfo(player, status);                    await this.previousTrackInfoMessage.ModifyAsync(x =>                    {                        x.Embed = trackInfo;                        x.Components = this.musicMessageComponentHandler.CreateTrackButtons();                    });                }            }            else            {                if (this.playlist.Current() == null)                {                    await channel.SendMessageAsync(status);                }                else                {                    this.previousTrackInfoMessage = await channel.SendMessageAsync(embed: await this.musicEmbedHandler.CreateTrackInfo(player, status), components: this.musicMessageComponentHandler.CreateTrackButtons());                }            }        }        public async Task UpdatePlaylistInfo(IMessageChannel channel, int index)        {            if (this.previousPlaylistInfoMessage != null)            {                IMessage? lastMessage = null;                try                {                    lastMessage = (await channel.GetMessagesAsync(1).FlattenAsync()).FirstOrDefault();                }                // ReSharper disable once EmptyGeneralCatchClause                catch                {                }                if (lastMessage != null && lastMessage.Id != this.previousPlaylistInfoMessage?.Id)                {                    this.previousPlaylistInfoMessage = null;                }            }            var songs = this.playlist.GetMusicTracks(index, 10);            var total = this.playlist.Count();            if (this.previousPlaylistInfoMessage != null)            {                await this.previousPlaylistInfoMessage.ModifyAsync(x =>                {                    x.Embed = this.musicEmbedHandler.CreatePlaylistInfo(songs, total);                    x.Components = this.musicMessageComponentHandler.CreatePlaylistInfoButtons(index, total, songs.Count);                });            }            else            {                this.previousPlaylistInfoMessage = await channel.SendMessageAsync(                    embed: this.musicEmbedHandler.CreatePlaylistInfo(songs, total),                    components: this.musicMessageComponentHandler.CreatePlaylistInfoButtons(index, total, songs.Count));            }        }        public async Task Reply(IMessageChannel channel, string status)        {            await channel.SendMessageAsync(status);        }        public async Task Reply(IMessageChannel channel, string status, MessageComponent messageComponent)        {            await channel.SendMessageAsync(status, components: messageComponent);        }        public async Task Reply(IMessageChannel channel, string status, List<string> playlists)        {            var components = this.musicMessageComponentHandler.DisplayPlaylists(playlists);            foreach (var component in components)            {                await channel.SendMessageAsync(status, components: component);            }        }    }}